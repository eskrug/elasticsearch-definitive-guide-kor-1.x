[[preload-fielddata]]
=== fielddata의 사전(事前) 로드

Elasticsearch의 기본 동작은((("fielddata", "pre-loading"))) in-memory fielddata를 _지연시켜_ 로드 하는 것이다. 
Elasticsearch가 특정 field에 대해, fielddata가 필요한, query를 처음으로 만나면, 
index에 있는 각 segment에 대해, 전체 field를 메모리로 로드 한다.

작은 segment에서는 무시해도 될 정도의 시간이다. 하지만, 몇 개의 5GB짜리 segment를 가지고 있고, 메모리에 10 GB의 fielddata를 메모리로 로드 해야 한다면, 
이 과정은 수십 초가 소요될 수 있다. 짧은 응답 시간에 익숙한 사용자들은 응답하지 않는 웹사이트 때문에 놀랄 것이다.

이런 응답 시간 문제에 대응하는 세 가지 방법이 있다.

- fielddata를 미리 로드(Eagerly load)
- global ordinals를 미리 로드(Eagerly load)
- index warner로 cache를 미리 채우기

모두 다 동일한 개념(사용자가 검색을 실행할 때, 응답 시간 문제를 없애기 위해, fielddata를 사전 로드)을 가진 변종이다.

[[eager-fielddata]]
==== fielddata를 미리 로드하자

첫 번째 도구는 _eager loading_(미리 로드, 기본값인 지연 로드와는 대조적으로)((("eager loading", "of fielddata")))이라 한다. 
새로운 segment가 생성(refresh, flush, merge)되면, eager loading이 활성화된 field는, segment가 검색에 표시되기 _전에_ , segment별로 fielddata를 미리 로드한다.

즉, segment에 대한 첫 번째 query는 fielddata 로드를 발생시킬 필요가 없다. 왜냐하면, in-memory cache는 이미 채워져 있기 때문이다. 
_cold cache_ 로 인한 사용자의 응답 시간 문제를 방지한다.

사전(eager) 로드는 기본적으로 field별로 활성화된다. 따라서, 어느 field를 미리 로드할 지를 제어할 수 있다:

[source,js]
----
PUT /music/_mapping/_song
{
  "price_usd": {
    "type": "integer",
    "fielddata": {
      "loading" : "eager" <1>
    }
  }
}
----
<1> `fielddata.loading: eager` 로 설정하여, 이 field의 내용을 메모리로 미리 로드한다.

fielddata의 로드는 `update-mapping` API를 사용하여, 기존의 field에 `eager` 나 `lazy` 로 설정한다. 

[WARNING]
====

eager loading은 fielddata 로드의 비용 지불 위치를 옮겼을 뿐이다. 
query시에 지불하는 대신, refresh시에 지급한다.

큰 segment는 작은 segment보다 refresh에 더 많은 시간이 걸린다. 
일반적으로, 큰 segment는 이미 검색에 표시된, 작은 segment의 병합으로 생성된다. 
따라서 더 느린 refresh 시간은 중요하지 않다.

====

[[global-ordinals]]
==== Global Ordinals

fielddata(특히, 문자열)의 메모리 사용량을 줄이는 데 사용되는 기술 중의 하나가 ((("ordinals"))) _ordinal_ 이다.

각각 `status` field를 가진, 10억개의 document를 가지고 있다고 가정해 보자. 
`status_pending`, `status_published`, `status_deleted` 의 세 가지 상태가 있다. 
모든 document가 상태를 모두 문자열로 가지고 있다면, document당 14 ~ 16 byte(약 15GB)를 사용해야 한다.
	
그 대신, 그것들을 구분하여 정렬하고, 번호를 매길(0, 1, 2) 수 있다. 

    Ordinal | Term
    -------------------
    0       | status_deleted
    1       | status_pending
    2       | status_published	

ordinal 문자열은 ordinal 목록에 단 한번 저장된다. 
그리고, 각 document는 그것을 포함한 값을 가리키는 번호가 매겨진 ordinal를 사용할 뿐이다.

	Doc     | Ordinal
    -------------------------
    0       | 1  # pending
    1       | 1  # pending
    2       | 2  # published
    3       | 0  # deleted

이것은 메모리 사용량을 15GB에서 1GB이하로 줄인다!

그러나, 문제가 있다. fielddata cache는 _segment별_ 로 존재한다. 
어떤 segment가 두 가지 상태&#x2014;(`status_deleted` 와 `status_published` )만을 가지고 있다면, 
결과가 되는 ordinals(0, 1)은 세 가지 상태 모두를 가지는 segment에 대한 ordinals와 동일하지 않을 것이다.

`status` field에 `terms` 집계를 실행하려면, 실제 문자열 값을 집계해야 한다. 
즉, 모든 segment에서 동일한 값을 확인해야 한다. 이렇게 하는 단순한 방식은 각 segment에서 집계를 실행하고, 
각 segment에서 문자열 값을 반환하고, 그 다음에 그들을 전체 결과로 축소하는 것이다. 
이렇게 하면, CPU를 많이 사용하여 느려질 것이다.

이를 대신하여, _global ordinal_ 라는 구조를 사용한다.((("global ordinals"))) 
global ordinal는 fielddata 위에 구축된, 작은 메모리 데이터 구조이다. 
유일한 값은 _모든 segment_ 에서 확인되어, 이미 언급한 것처럼 ordinals 목록에 저장된다.

이제, `단어` 집계는 global ordinal에서 집계할 수 있다. 
ordinal을 실제 문자열 값으로 바꾸는 변환은 집계의 마지막에 한번만 일어난다. 
이것은 3~4 가지 요소로 인하여, 집계와 정렬의 성능을 증가시킨다.

===== Global ordinals의 구축

물론, 공짜는 없다.((("global ordinals", "building"))) global ordinal는 index의 모든 segment에 대한 것이다. 
따라서, 새로운 segment가 생성되거나 오래된 segment가 삭제되면, global ordinal는 다시 구축되어야 한다. 
다시 구축하려면, 모든 segment에서 유일한 단어 모두를 읽어야 한다. 
cardinality가 높을수록(유일한 단어가 많을수록), 이 과정이 더 오래 걸린다.

global ordinal는 in-memory fielddata와 doc values 위에 구축된다. 
사실, 이것이 doc values만큼 잘 동작할 수 있는 주요한 이유중의 하나이다.

fielddata 로드와 마찬가지로, global ordinal는 기본적으로, 지연되어 만들어진다. 
index에 대해 fielddata를 필요로 하는 첫 번째 요청은 global ordinal의 구축을 발생시킨다. 
field의 cardinality에 따라, 이것은 사용자에게 심각한 응답 시간 문제로 나타날 수 있다. 
global ordinal가 다시 구축되고 나면, index의 segment에 변화(refresh, flush, merge)가 있을 때까지, 재사용된다.

[[eager-global-ordinals]]
===== Global ordinals의 사전(事前) 구축

개별 문자열 field는((("eager loading", "of global ordinals")))((("global ordinals", "eager"))) global ordinal를 미리 구축하도록, 설정될 수 있다.

[source,js]
----
PUT /music/_mapping/_song
{
  "song_title": {mapping.
    "type": "string",
    "fielddata": {
      "loading" : "eager_global_ordinals" <1>
    }
  }
}
----
<1> `eager_global_ordinals` 를 설정하여, fielddata의 사전(eager) 로드를 적용한다.

fielddata의 사전(eager) 로드와 마찬가지로, eager global ordinal는 
새로운 segment가 검색에 표시되기 전에 구축된다.

[NOTE]
=========================
ordinals는 문자열에 사용하기 위해서만 구죽해야 한다. 수치 데이터(integers, geopoints,
dates 등)는 값자체가 고유한 서수적 특징을 가지므로 ordinal mapping을 필요로 하지 않는다.

따라서 eager global ordinals은 문자열 field에서만 활성화 할 수 있다.
=========================

doc values 또한 자신의 eager global ordinal를 구축할 수 있다.

[source,js]
----
PUT /music/_mapping/_song
{
  "song_title": {
    "type":       "string",
    "doc_values": true,
    "fielddata": {
      "loading" : "eager_global_ordinals" <1>
    }
  }
}
----
<1> 이 경우에, fielddata는 메모리에 로드 되지 않는다. 그러나 doc values가 filesystem cache에 로드 된다.	

미리 로드 되는 fielddata와 달리, global ordinals의 사전(eager) 구축은 데이터의 _실시간_ 이라는 측면에 영향을 줄 수 있다. 
매우 높은 cardinality field의 경우, global ordinals의 구축은 refresh를 몇 초 정도 지연시킬 수 있다. 
refresh시에 매번 비용을 지불하느냐, 아니면, refresh 후에 첫 번째 query에서 비용을 지불하느냐를 선택해야 한다. 
자주 색인하고 거의 query를 하지 않는다면, 아마도 refresh할 때마다가 아닌, query시에 비용을 지불하는 것이 더 나을 것이다. 

[TIP]
====

global ordinals를 아끼자. 다시 구축하는데 수초가 걸리는, 매우 높은 cardinality를 가진 field가 있다면, 
global ordinals가 더 오랫동안 유효하도록, `refresh_interval` 을 증가시키자. 
이것은 global ordinals의 재 구축 횟수를 줄여, CPU 사용량을 줄인다.

====

[[index-warmers]]
==== Index Warmers

마지막으로 _index warmer_ 를 보자. warmer는((("index warmers"))) fielddata의 사전(eager) 로드와 사전(eager) global ordinals보다 선행하지만 여전히 유용하다. 
index warmer는 새로운 segment가 검색에 표시되기 전에, 실행될 query와 집계를 지정할 수 있다. 
이 개념은 사용자가 응답 시간 문제를 결코 보지 못하게 하기 위해, 미리 채우거나, cache를 _warm_ 하는 것이다.

원래, warmer의 가장 중요한 사용처는 fielddata의 사전 로드를 확인하는 것이었다. 이것은 일반적으로 가장 많은 비용이 소요되는 단계이다. 
지금은, 이것이 위에서 언급한 기술로 더 잘 제어된다. 그러나, warmer는 filter cache를 미리 만드는데 사용될 수 있고, 
선택에 따라, fielddata를 미리 로드 하는데 여전히 사용할 수 있다.

warmer를 등록하고, 무슨 일이 벌어지는지 살펴보자:

[source,js]
----
PUT /music/_warmer/warmer_1 <1>
{
  "query" : {
    "filtered" : {
      "filter" : {
        "bool": {
          "should": [ <2>
            { "term": { "tag": "rock"        }},
            { "term": { "tag": "hiphop"      }},
            { "term": { "tag": "electronics" }}
          ]
        }
      }
    }
  },
  "aggs" : {
    "price" : {
      "histogram" : {
        "field" : "price", <3>
        "interval" : 10
      }
    }
  }
}
----
<1> warmer는 index(`music`)와 관련되어 있고, 마지막에 `_warmer` 를 사용하여 등록되었다. 그리고 `warmer_1` 이 고유한 ID이다.
<2> 3개의 가장 인기 있는 음악 장르는 미리 구축된 자신들의 filter cache를 가지고 있다.
<3> `price` field에 대한 fielddata와 global ordinal은 미리 로드된다.

warmer는 특정 index에 대해 등록된다.((("warmers", see="index warmers"))) 
index별로 다수의 warmer를 가질 수 있기 때문에, 각 warmer는 교유한 ID를 가진다.

그 다음에 query(어떤 query라도)를 지정하면 된다. 
query, filter, 집계, 정렬 값 script 등의, 모든 유효한 query DSL 등을 포함할 수 있다. 
핵심은 적절한 cache가 미리 채워지도록, 사용자가 만들어내는 요청을 대표하는 query를 등록하는 것이다. 

새로운 segment가 생성되면, Elasticsearch는 warmer에 등록된 query를 _문자 그대로_ 실행한다. 
이 query를 실행하여 cache를 로드하는 것이다. 모든 query가 실행된 후에만, segment는 검색에 표시될 것이다.

[WARNING]
====
사전(eager) 로드와 마찬가지로, warmer는 cold cache의 비용 지불의 위치를 refresh할 때로 옮긴 것이다. 
warmer를 등록할 때에는 신중해야 한다. 모든 cache가 채워지도록, 수천 개의 warmer를 등록 _할 수 있다_. 그러나, 그것은 새로운 segment를 검색이 가능하도록 만드는데 소요되는 시간을 급격히 증가시킨다.

실제 상황에서는, 사용자의 query 대부분을 대표하는 query 중 소수만을 선택해 등록한다.
====

이 설명에서 생략된 관리 세부 사항(현재 warmer를 얻는 방법, warmer의 삭제 방법 등)이 많이 있다. 나머지 세부 사항에 대해서는 http://bit.ly/1AUGwys[warmers 문서]를 참고하자.
