[[fielddata]]
=== Fielddata

집계는 _fielddata_ (<<fielddata-intro, fielddata 소개>>에서 간단히 소개된)로 알려진 데이터 구조를 통해, 
동작한다. ((("fielddata")))((("memory usage", "fielddata")))fielddata는 Elasticsearch의 cluster에서, 
메모리의 가장 큰 소비자이다. 때문에, 그것이 동작하는 방법을 이해하는 것은 중요하다.

[TIP]
==================================================

fielddata는 메모리에 바로 로드 되거나, 색인 시에 구축되어 디스크에 저장될 수 있다.((("fielddata", "loaded into memory vs. on disk"))) 
나중에, <<doc-values>>에서 디스크상(on-disk)의 fielddata에 대해 이야기할 것이다. 
지금은, 현재 Elasticsearch의 기본 동작 모드인, 메모리상(in-memory)의 fielddata에 집중할 것이다. 
이것은 향후 버전에서 변경할 수 있다.

==================================================

inverted indices는 특정 작업에 대해서만 효율적이기 때문에, fielddata는 존재한다. 
inverted index는((("inverted index", "fielddata versus"))) 단어를 포함하는 document를 찾는 것에 탁월하다. 
정반대의 방향(단어가 어떤 하나의 document에 존재하는지를 판단하는 것)에서는 잘 동작하지 않는다. 
집계는 이 두 번째 액세스 형태가 필요하다.

다음의 inverted index를 고려해 보자:
	
    Term      Doc_1   Doc_2   Doc_3
    ------------------------------------
    brown   |   X   |   X   |
    dog     |   X   |       |   X
    dogs    |       |   X   |   X
    fox     |   X   |       |   X
    foxes   |       |   X   |
    in      |       |   X   |
    jumped  |   X   |       |   X
    lazy    |   X   |   X   |
    leap    |       |   X   |
    over    |   X   |   X   |   X
    quick   |   X   |   X   |   X
    summer  |       |   X   |
    the     |   X   |       |   X
    ------------------------------------

+brown+ 을 언급하는 document에서, 단어의 완벽한 목록을 만들려면, 아래와 같은 query를 만들 어야 한다:

[source,js]
----
GET /my_index/_search
{
  "query" : {
    "match" : {
      "body" : "brown"
    }
  },
  "aggs" : {
    "popular_terms": {
      "terms" : {
        "field" : "body"
      }
    }
  }
}
----

query 부분은 간단하고 효율적이다. inverted index는 단어를 기준으로 정렬된다. 그래서, 먼저 단어 목록에서 +brown+ 을 찾고, 
그 다음에 +brown+ 을 포함하는 document를 찾기 위해, column 전부를 검색한다. `Doc_1` 과 `Doc_2` 가 token +brown+ 을 포함하는 것을, 매우 빠르게 볼 수 있다.

그 다음에 집계 부분에서, `Doc_1` 과 `Doc_2` 에 있는 유일한 단어를 검색해야 한다.((("aggregations", "fielddata", "using instead of inverted index")))
inverted index에서 이렇게 하면, 비용이 많이 드는 프로세스가 될 것이다. 
index에서 모든 단어에 대해 반복해야 하고, `Doc_1` 과 `Doc_2` 의 column에서 token을 수집해야 한다. 
이것은 매우 느리고, 조정도 어렵다. 단어와 document의 수가 증가할수록, 실행시간도 증가할 것이다.

fielddata는 그 관계를 반대로 하여, 이 문제를 해결한다. 
inverted index는 단어를 단어를 포함하고 있는 document에 mapping하는 반면에, 
fielddata는 document를 document에 의해 포함되는 단어에 mapping한다:

    Doc      Terms
    -----------------------------------------------------------------
    Doc_1 | brown, dog, fox, jumped, lazy, over, quick, the
    Doc_2 | brown, dogs, foxes, in, lazy, leap, over, quick, summer
    Doc_3 | dog, dogs, fox, jumped, over, quick, the
    -----------------------------------------------------------------

데이터가 uninverted되면, `Doc_1` 과 `Doc_2` 에서 유일한 token을 수집하는 것은 간단하다. 
각 document의 행으로 가서, 단어 모두를 수집하고, 두 집합을 조합하면 된다.

[TIP]
==================================================

fielddata cache는 segment별이다.((("fielddata cache")))((("segments", "fielddata cache"))) 즉, 새로운 segment가 검색에 나타났을 때, 
기존 segment에서의 fielddata cache는 여전히 유효하다. 
새로운 segment에 대한 데이터만 메모리에 로드되면 된다.

==================================================

따라서, 검색과 집계는 밀접하게 엮여 있다. 검색은 inverted index를 이용하여, document를 찾는다. 
집계는 fielddata에서 값을 수집하고 집계한다. fielddata 자체는 inverted index에서 생성된다.

이 장의 나머지 부분은 fielddata의 메모리 공간을 줄이거나, 
실행 속도를 증가시키는 등의 다양한 기능에 대해 이야기할 것이다.

[NOTE]
==================================================

fielddata가 집계에만 사용되는 것은 아니다.((("fielddata", "uses other than aggregations"))) 특정 document에 
포함된 값을 조회해야 하는 모든 연산에도 필요하다. 집계 이외에도, 정렬, field 값에 액세스하는 scripts, 
부모-자식 관계(<<parent-child, 부모-자식 관계>> 참조), 그리고, 
<<geo-distance,`geo_distance` >>  같은 특정 유형의 query나 filter에도 사용된다.

==================================================
