=== 다수의 document 검색

Elasticsearch가 빠른 만큼, 여전히 더 빨라질 수 있다.((("documents", "retrieving multiple"))) 다수의 요청을 하나로 조합하는 것은, 
각 요청을 개별적으로 처리하는 경우에 발생하는 네트워크 부하를 피할 수 있다. 만약 Elasticsearch에서 다수의 document를 검색할 필요가 있다면, 
document 별로 검색하는 대신, _multi-get_ 이나 `mget` API((("mget (multi-get) API")))를 사용하여, 한번의 요청으로 모두 가져오는 것이 더 빠르다.

`mget` API는 각 ((("docs array", "in request")))요소가 가져오려는 document의 `_index`, `_type`, `_id` 의
 metadata를 가진 docs 배열을 지정해야 한다. 하나 이상의 특정 field만 가져오려면, `_source` field를 지정할 수도 있다:

[source,js]
--------------------------------------------------
GET /_mget
{
   "docs" : [
      {
         "_index" : "website",
         "_type" :  "blog",
         "_id" :    2
      },
      {
         "_index" : "website",
         "_type" :  "pageviews",
         "_id" :    1,
         "_source": "views"
      }
   ]
}
--------------------------------------------------
// SENSE: 030_Data/50_Mget.json

응답 body도 요청에서 지정한 것과 동일한 순서로, document별로 응답을 포함하는 `docs` 배열을((("docs array", "in response body"))) 포함한다. 
이들 응답 각각은 개별 <<get-doc, `get` 요청>>에서 얻은 응답 body와 같다.

[source,js]
--------------------------------------------------
{
   "docs" : [
      {
         "_index" :   "website",
         "_id" :      "2",
         "_type" :    "blog",
         "found" :    true,
         "_source" : {
            "text" :  "This is a piece of cake...",
            "title" : "My first external blog entry"
         },
         "_version" : 10
      },
      {
         "_index" :   "website",
         "_id" :      "1",
         "_type" :    "pageviews",
         "found" :    true,
         "_version" : 2,
         "_source" : {
            "views" : 2
         }
      }
   ]
}
--------------------------------------------------
// SENSE: 030_Data/50_Mget.json

동일한 `_index` 에 있는(심지어 동일한 `_type` 의) 모든 document를 검색하려 한다면, URL에 기본 `/_index` 나 기본 `/_index/_type` 을 지정하면 된다.

개별 요청에 이런 값들을 재정의하면 된다:

[source,js]
--------------------------------------------------
GET /website/blog/_mget
{
   "docs" : [
      { "_id" : 2 },
      { "_type" : "pageviews", "_id" :   1 }
   ]
}
--------------------------------------------------
// SENSE: 030_Data/50_Mget.json

사실, 모든 document가 동일한 `_index` 와 `_type` 을 가진다면, 모든 `docs` 배열 대신에, `ids` 의 배열을 넘겨도 된다:

[source,js]
--------------------------------------------------
GET /website/blog/_mget
{
   "ids" : [ "2", "1" ]
}
--------------------------------------------------

요청한 것 중 두 번째 document가 존재하지 않는다는 것을 눈 여겨 보자. type을 `blog` 로 지정했으나, 
`pageviews` type의 document ID를 `1` 로 지정했다. 응답 body에 document가 존재하지 않는다고 나타난다:

[source,js]
--------------------------------------------------
{
  "docs" : [
    {
      "_index" :   "website",
      "_type" :    "blog",
      "_id" :      "2",
      "_version" : 10,
      "found" :    true,
      "_source" : {
        "title":   "My first external blog entry",
        "text":    "This is a piece of cake..."
      }
    },
    {
      "_index" :   "website",
      "_type" :    "blog",
      "_id" :      "1",
      "found" :    false  <1>
    }
  ]
}
--------------------------------------------------
// SENSE: 030_Data/50_Mget.json
<1> 이 document는 존재하지 않는다.

두 번째 document가 발견되지 않는다는 사실은, 첫 번째 document를 검색하는데 아무런 영향을 
미치지 못한다. 각 document는 개별적으로 검색되고 보고된다.

[NOTE]
====
비록 document가 하나도 발견되지 않았지만, 위의 요청에 대한 HTTP 상태 code는 `200` 이다. 
사실, document가 _전혀_  발견되지 않아도 여전히 `200` 이다. 그 이유는 `mget` 요청 자체가 성공적으로 완료되었기 때문이다. 
개별 document의 성공 여부를 결정하려면 ((("found flag")))`found` flag를 확인해야 한다.
====
