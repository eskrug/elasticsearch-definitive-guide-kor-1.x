[[version-control]]
=== 충돌 취급

((("conflicts", "dealing with")))`index` API를 사용하여 document를 업데이트할 경우, 원래의 document를 읽고, 
변경을 하고, 한번에 _전체 document_를 재색인 한다. 가장 최근의 색인 요청이 저장된다. 마지막으로 색인된 document가 Elasticsearch에 한번 저장된다. 
누군가 그 사이에 document를 변경했다면, 그 변경 사항은 사라진다. 

많은 경우, 이런 상황은 문제가 되지 않는다. 아마 주 데이터의 저장소는 RDB이고, Elasticsearch에 검색 가능하도록 그 데이터를 복사할 뿐이다. 
아마도 두 사람이 동일한 document를, 동시에 변경하는 경우는 거의 없을 것이다. 경우에 따라, 변경 사항이 사라지는 경우가 있겠지만, 크게 문제가 되지 않는다.

그러나 때때로 변경 사항을 잃어 버린 것이, _매우 중요_ 할 수도 있다. Elasticsearch를 온라인 상점에서, 
많은 상품들의 재고를 저장하는데 사용하고 있다고 가정해 보자. 상품을 팔 때마다 Elasticsearch에서 재고를 감소시켜야 한다.

어느 날 관리자가 sale을 하기로 했다. 갑자기 매초마다 여러 가지 상품이 팔릴 것이다. 동시에 동작하고 있는 두 개의 web 프로세스를 생각해 보자. 
둘 모두 하나의 상품에 대한 판매를 각각 진행하고 있는 것을 <<img-data-lww, 동시성 제어가 없는 경우의 결과>>에서 볼수 있다.

[[img-data-lww]]
.동시성 제어가 없는 경우의 결과
image::images/elas_0301.png["동시성 제어가 없는 경우의 결과",width="50%",align="center"]

`web_2` 가 `재고 수` 복사본의 최신 상태임을 알지 못하기 때문에,`재고 수` 에 대한 `web_1` 의 변화가 사라졌다. 
결과적으로, 실제로 가지고 있는 것보다 더 많은 상품이 있다고 생각하여, 존재하지 않는 상품을 고객들에게 판매하여, 고객을 실망시킬 것이다.

변화가 더 자주 발생할수록, 데이터를 읽는 것과 업데이트 사이에 간격이 더 길수록, 변경 사항이 사라질 가능성은 더 많아진다.

데이터베이스의 세계에서, 동시에 업데이트가 이루어지는 경우에, 변경 사항이 사라지지 않을 것을 보장하기 위해((("pessimistic concurrency control")))((("concurrency control"))), 
흔히 사용되는 두 가지 방법이 있다:

_비관적인 동시성 제어_::

RDB에서 널이 사용된다. 변경 사항이 충돌할 가능성이 있고, 그래서 block은 충돌을 막기 위해 resource에 접근한다고 가정한다. 
전형적인 예는 데이터를 읽기 전에 row를 잠그는 것이다. 데이터를 잠근 thread만 해당 row에 있는 데이터를 바꿀 수 있도록 하는 것이다.

_낙관적인 동시성 제어_::

Elasticsearch에서 사용된다. ((("optimistic concurrency control")))충돌은 발생할 가능성이 적고, 시도되는 작업을 막지 않는다. 그러나, 읽기와 쓰기 사이에 근본 데이터가 변경되면, 
업데이트는 실패한다. 충돌을 해결하는 방법은 응용프로그램에 달려 있다. 예를 들어 새로운 데이터를 이용하여 업데이트를 다시 시도할 수도 있거나, 새로운 데이터를 사용하거나, 사용자에게 상황을 보고할 수도 있다.

[[optimistic-concurrency-control]]
=== 낙관적인 동시성 제어

Elasticsearch는 분산되어 있다. document가 ((("concurrency control", "optimistic")))생성되거나, 업데이트, 삭제되면, 
document의 새로운 버전은 cluster의 다른 node로 복제된다. Elasticsearch는 비동기적이고 동시성을 가진다. 
즉, 복제 요청이 병렬로 보내지고, _차례대로 도착하지 않을지도_  모른다. Elasticsearch 기존 버전의 document가 새로운 버전의 document를 절대로 덮어쓰지 않을 것을 보장하는 방법이 필요하다.

위에서 `index`, `get`, `delete` 를 이야기할 때, 모든 document가 `_version` 넘버를 가지며, document가 변경될 때마다 증가한다고 이야기 했다. 
Elasticsearch는 변경 사항이 올바르게 적용되었다는 것을 보장하기 위해, `_version` 넘버를 사용한다. 기존 버전의 document가 새로운 버전보다 늦게 도착하면, 간단히 무시한다.

응용프로그램에 의해 만들어지는 변경 사항의 충돌이, 데이터 손실로 나타나지 않도록 보장하기 위해((("version number (documents)", "using to avoid conflicts"))), 
'_version' 넘버를 이용할 수 있다. 변경하려는 document의 `버전` 넘버를 지정함으로써 가능하다. 해당 버전이 더 이상 최신이 아니면, 요청은 실패한다.

새로운 블로그 포스트를 생성하자:

[source,js]
--------------------------------------------------
PUT /website/blog/1/_create
{
  "title": "My first blog entry",
  "text":  "Just trying this out..."
}
--------------------------------------------------
// SENSE: 030_Data/40_Concurrency.json

응답 body는 새로 생성된 document는 `_version` 넘버 1을 나타낸다. 이 document를 변경한다고 생각해 보자. 
web form에 이 데이터를 표시하고, 수정하고, 새로운 버전을 저장한다.

먼저, 이 document를 가져오자:

[source,js]
--------------------------------------------------
GET /website/blog/1
--------------------------------------------------
// SENSE: 030_Data/40_Concurrency.json

응답 body는 동일한 `_version` 넘버 1을 포함하고 있다:

[source,js]
--------------------------------------------------
{
  "_index" :   "website",
  "_type" :    "blog",
  "_id" :      "1",
  "_version" : 1,
  "found" :    true,
  "_source" :  {
      "title": "My first blog entry",
      "text":  "Just trying this out..."
  }
}
--------------------------------------------------

이제 document를 다시 색인 하여, 변경 사항을 저장하자. 적용하려는 변경 사항에 `버전` 을 지정한다.

[source,js]
--------------------------------------------------
PUT /website/blog/1?version=1 <1>
{
  "title": "My first blog entry",
  "text":  "Starting to get the hang of this..."
}
--------------------------------------------------
// SENSE: 030_Data/40_Concurrency.json
<1> index에 있는 document의 현재 `_version` 이 버전 `1` 인 경우에만 업데이트 되어야 한다.	

이 요청은 성공한다. 그리고 응답 body는 `_version` 이 `2` 로 증가되었음을 나타낸다.

[source,js]
--------------------------------------------------
{
  "_index":   "website",
  "_type":    "blog",
  "_id":      "1",
  "_version": 2
  "created":  false
}
--------------------------------------------------
// SENSE: 030_Data/40_Concurrency.json

그러나, 여전히 `version=1` 을 지정하여, 동일한 index 요청을 다시 실행하면, Elasticsearch는 HTTP 응답 code 
`409 Conflict` 로 응답할 것이다. body는 아래와 같다:

[source,js]
--------------------------------------------------
{
  "error" : "VersionConflictEngineException[[website][2] [blog][1]:
             version conflict, current [2], provided [1]]",
  "status" : 409
}
--------------------------------------------------
// SENSE: 030_Data/40_Concurrency.json

이것은 Elasticsearch에 있는 document의 현재 `_version` 넘버가 `2` 인데, 버전 `1` 을 업데이트하려 했다고 알려준다.

이에 따라 해야 할 작업은, 응용프로그램의 요구사항에 따라 달라진다. 다른 이가 이미 document를 변경했다고, 
다시 저장하기 전에 변경사항을 검토해야 한다고, 사용자에게 알려줘야 한다. 그렇지 않으면, 위의 상품 `재고` 의 예처럼, 최신 document를 가져오고, 변경사항을 다시 적용하려 할 것이다.

document는 `버전` 매개변수를 사용해 수정이나 삭제를 위한 모든 API가 낙관적인 동시성 제어를 코드의 일부분에 적용할 수 있도록 한다.

==== 외부 시스템에서 버전 사용

일반적인 설정은 기본 데이터 저장소로서 다른 데이터베이스를 사용하고, 데이터를 검색 가능하도록((("version number (documents)", "using an external version number")))((("external version numbers"))) Elasticsearch를 사용하는 것이다. 
즉, 기본 데이터 저장소에서의 모든 수정 사항을, 수정이 발생하자마자, Elasticsearch에 복사할 필요가 있다. 
멀티프로세스가 데이터 동기화를 책임지고 있다면, 위에서 언급한 것과 유사한 동시성 문제가 발생할 수 있다.

주 데이터베이스가 이미 버전(또는 버전 넘버로 사용될 수 있는 `timestamp` 같은 값) 넘버를 가지고 있다면, 
query string에((("query strings", "version_type=external"))) `version_type=external` 을 추가함으로써, Elasticsearch에 이런 버전을 그대로 쓸 수 있다. 
버전은 0보다 크고, `9.2e+18` --보다 작은, 정수여야 한다. Java에서는 양수 `long` 이다.

외부 버전 넘버를 다루는 방법은, 위에서 언급했던 내부 버전과 약간 다르다. 현재의 `_version` 이 요청에 지정된 버전과 _같다_ 는 것을 확인하는 대신, 
Elasticsearch는 현재의 버전이 지정한 `_version` 보다 _작은지_ 를 확인한다. 요청이 성공하면, 외부 버전을 document의 새로운 `_version` 으로 저장한다.

외부 버전은 index, delete 요청뿐만 아니라, 새로운 document를 _생성할_  때에도 지정할 수 있다.

예를 들면, 외부 버전을 `5` 로 해서, 새로운 블로그 포스트를 생성하려면, 아래와 같이 한다:

[source,js]
--------------------------------------------------
PUT /website/blog/2?version=5&version_type=external
{
  "title": "My first external blog entry",
  "text":  "Starting to get the hang of this..."
}
--------------------------------------------------
// SENSE: 030_Data/40_External_versions.json

응답에서, 현재 `_version`  넘버가 `5` 라는 것을 볼 수 있다:

[source,js]
--------------------------------------------------
{
  "_index":   "website",
  "_type":    "blog",
  "_id":      "2",
  "_version": 5,
  "created":  true
}
--------------------------------------------------

이제, 새로운 `버전` 넘버를 `10` 으로 해서, 이 document를 업데이트해 보자.

[source,js]
--------------------------------------------------
PUT /website/blog/2?version=10&version_type=external
{
  "title": "My first external blog entry",
  "text":  "This is a piece of cake..."
}
--------------------------------------------------
// SENSE: 030_Data/40_External_versions.json

요청은 성공하고, 현재의 `_version` 은 `10` 으로 설정된다.

[source,js]
--------------------------------------------------
{
  "_index":   "website",
  "_type":    "blog",
  "_id":      "2",
  "_version": 10,
  "created":  false
}
--------------------------------------------------

이 요청을 다시 실행하면, 전에 보았던 것과 동일한 충돌 에러를 내면서, 실패할 것이다. 
왜냐하면, 지정한 외부 버전이 Elasticsearch의 현재 버전보다 높지 않기 때문이다.
